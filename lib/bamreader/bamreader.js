// Generated by CoffeeScript 1.7.1

/*
 * BAMReader by Shin Suzuki(@shinout)
 */
var BAMReader, CIGAR_ARR, FLAGS, SEQ_ARR, createInflateRaw, createReadStream;

createReadStream = require("fs").createReadStream;

createInflateRaw = require("zlib").createInflateRaw;

SEQ_ARR = "=ACMGRSVTWYHKDBN".split("");

CIGAR_ARR = "MIDNSHP=X".split("");

FLAGS = ["multiple", "allmatches", "unmapped", "next_unmapped", "reversed", "next_reversed", "first", "last", "secondary", "lowquality", "duplicate"];

BAMReader = (function() {
  function BAMReader(bamfile, options) {
    this.bamfile = bamfile;
    this.options = options != null ? options : {};
    process.nextTick((function(_this) {
      return function() {
        return _this.begin();
      };
    })(this));
  }

  BAMReader.create = function(bamfile, options) {
    if (options == null) {
      options = {};
    }
    return new BAMReader(bamfile, options);
  };

  BAMReader.prototype.on = function(name, fn) {
    switch (name) {
      case "sam":
        return this.onSam = fn;
      case "bam":
        return this.onBam = fn;
      case "end":
        return this.onEnd = fn;
      case "header":
        return this.onHeader = fn;
    }
  };

  BAMReader.prototype.begin = function() {
    var count, curXi, inflateRaw, inflatedBuffers, lastXi, onBam, onEnd, onHeader, onSam, options, readAlignment, readHeader, refs, remainedBuffer, rstream, xi;
    onBam = this.onBam;
    onSam = this.onSam;
    onEnd = this.onEnd;
    onHeader = this.onHeader;
    options = this.options;
    count = 0;
    xi = 0;
    refs = {};
    curXi = 1;
    lastXi = 0;
    inflatedBuffers = {};
    inflateRaw = function(i, buffer) {
      var buffers, engine, flow, nread;
      engine = createInflateRaw({
        chunkSize: 65535
      });
      nread = 0;
      buffers = [];
      engine.on("error", function(err) {
        engine.removeListener("end");
        engine.removeListener("readable", flow);
        return console.error(err);
      });
      engine.on("end", function() {
        var buf, inflatedBuffer;
        buf = Buffer.concat(buffers, nread);
        buffers = [];
        if (i === 0) {
          readHeader(buf);
        } else {
          inflatedBuffers[i] = buf;
        }
        engine.close();
        while (inflatedBuffer = inflatedBuffers[curXi]) {
          readAlignment(inflatedBuffer, i);
          delete inflatedBuffers[curXi];
          curXi++;
        }
        if (onEnd && curXi === lastXi) {
          return onEnd();
        }
      });
      flow = function() {
        var chunk;
        while (null !== (chunk = engine.read())) {
          buffers.push(chunk);
          nread += chunk.length;
        }
        return engine.once("readable", flow);
      };
      engine.end(buffer);
      return flow();
    };
    rstream = createReadStream(this.bamfile, {
      highWaterMark: 1024 * 1024 - 1
    });
    remainedBuffer = new Buffer(0);
    rstream.on("data", function(newBuffer) {
      var buf, cdataBuffer, cdataLen, _results;
      buf = Buffer.concat([remainedBuffer, newBuffer], remainedBuffer.length + newBuffer.length);
      _results = [];
      while (true) {
        if (buf.length <= 26) {
          remainedBuffer = buf.length ? buf : new Buffer(0);
          break;
        }
        cdataLen = buf.readUInt16LE(16) - 25;
        if (buf.length < cdataLen + 26) {
          remainedBuffer = buf;
          break;
        }
        cdataBuffer = buf.slice(18, cdataLen + 18);
        inflateRaw(xi++, cdataBuffer);
        _results.push(buf = buf.slice(26 + cdataLen));
      }
      return _results;
    });
    rstream.on("end", function() {
      return lastXi = xi;
    });
    readHeader = function(bambuf) {
      var cursor, header, headerLen, i, nRef, name, nameLen, refLen, _i;
      headerLen = bambuf.readInt32LE(4);
      header = bambuf.slice(8, headerLen + 8).toString("ascii");
      cursor = headerLen + 8;
      nRef = bambuf.readInt32LE(cursor);
      cursor += 4;
      for (i = _i = 0; 0 <= nRef ? _i < nRef : _i > nRef; i = 0 <= nRef ? ++_i : --_i) {
        nameLen = bambuf.readInt32LE(cursor);
        cursor += 4;
        name = bambuf.slice(cursor, cursor + nameLen - 1).toString("ascii");
        cursor += nameLen;
        refLen = bambuf.readInt32LE(cursor);
        cursor += 4;
        refs[i] = {
          name: name,
          len: refLen
        };
      }
      if (onHeader) {
        return onHeader(header);
      }
    };
    return readAlignment = function(buf, k) {
      var arrayLen, bamline, bin, blockSize, byte, char, cigar, cigarLen, cursor, flag, flagname, flags, hLen, i, itr, mapq, name, nextPos, nextRefId, num, pos, qual, readName, readNameLen, refId, rname, rnext, samline, second, seq, seqBits, seqLen, seqLenByte, subtype, tLen, tag, tags, valtype, zLen, _i, _j, _k, _len, _len1, _results;
      itr = 0;
      _results = [];
      while (buf.length) {
        cursor = 0;
        blockSize = buf.readInt32LE(cursor);
        if (buf.length < blockSize) {
          break;
        }
        cursor += 4;
        count++;
        refId = buf.readInt32LE(cursor);
        rname = refId === -1 ? "*" : refs[refId].name;
        cursor += 4;
        pos = buf.readInt32LE(cursor);
        cursor += 4;
        readNameLen = buf.readUInt8(cursor);
        cursor++;
        mapq = buf.readUInt8(cursor);
        cursor++;
        bin = buf.readUInt16LE(cursor);
        cursor += 2;
        cigarLen = buf.readUInt16LE(cursor);
        cursor += 2;
        flag = buf.readUInt16LE(cursor);
        flags = {};
        for (i = _i = 0, _len = FLAGS.length; _i < _len; i = ++_i) {
          flagname = FLAGS[i];
          flags[flagname] = !!(flag & (0x01 << i));
        }
        cursor += 2;
        seqLen = buf.readInt32LE(cursor);
        cursor += 4;
        nextRefId = buf.readInt32LE(cursor);
        rnext = nextRefId === -1 ? "*" : refs[nextRefId].name;
        cursor += 4;
        nextPos = buf.readInt32LE(cursor);
        cursor += 4;
        tLen = buf.readInt32LE(cursor);
        cursor += 4;
        readName = buf.slice(cursor, cursor + readNameLen - 1).toString("ascii");
        cursor += readNameLen;
        cigar = [];
        for (i = _j = 0; 0 <= cigarLen ? _j < cigarLen : _j > cigarLen; i = 0 <= cigarLen ? ++_j : --_j) {
          num = buf.readUInt32LE(cursor, cursor + 4);
          char = CIGAR_ARR[num & 0x0f];
          num = num >> 4;
          cigar.push(num + char);
          cursor += 4;
        }
        cigar = cigar.join("");
        seqLenByte = Math.floor((seqLen + 1) / 2);
        seqBits = buf.slice(cursor, cursor + seqLenByte);
        seq = [];
        for (_k = 0, _len1 = seqBits.length; _k < _len1; _k++) {
          byte = seqBits[_k];
          seq.push(SEQ_ARR[byte >> 4]);
          second = SEQ_ARR[byte & 0x0F];
          if (second !== "=") {
            seq.push(second);
          }
        }
        seq = seq.join("");
        cursor += seqLenByte;
        qual = ((function() {
          var _l, _results1;
          _results1 = [];
          for (i = _l = 0; 0 <= seqLen ? _l < seqLen : _l > seqLen; i = 0 <= seqLen ? ++_l : --_l) {
            _results1.push(String.fromCharCode(buf[cursor + i] + 33));
          }
          return _results1;
        })()).join("");
        cursor += seqLen;
        tags = {};
        while (true) {
          if (cursor - 4 >= blockSize) {
            break;
          }
          tag = buf.slice(cursor, cursor + 2).toString("ascii");
          cursor += 2;
          valtype = String.fromCharCode(buf[cursor]);
          cursor++;
          switch (valtype) {
            case "A":
              tags[tag] = {
                type: valtype,
                value: String.fromCharCode(buf[cursor])
              };
              cursor++;
              break;
            case "c":
              tags[tag] = {
                type: "i",
                value: buf.readInt8(cursor)
              };
              cursor++;
              break;
            case "C":
              tags[tag] = {
                type: "i",
                value: buf.readUInt8(cursor)
              };
              cursor++;
              break;
            case "s":
              tags[tag] = {
                type: "i",
                value: buf.readInt16LE(cursor)
              };
              cursor += 2;
              break;
            case "S":
              tags[tag] = {
                type: "i",
                value: buf.readUInt16LE(cursor)
              };
              cursor += 2;
              break;
            case "i":
              tags[tag] = {
                type: "i",
                value: buf.readInt32LE(cursor)
              };
              cursor += 4;
              break;
            case "I":
              tags[tag] = {
                type: "i",
                value: buf.readUInt32LE(cursor)
              };
              cursor += 4;
              break;
            case "f":
              tags[tag] = {
                type: valtype,
                value: buf.readFloatLE(cursor)
              };
              cursor += 4;
              break;
            case "B":
              subtype = String.fromCharCode(buf[cursor]);
              cursor++;
              arrayLen = buf.readInt32LE(cursor);
              cursor += 4;
              switch (subtype) {
                case "c":
                  tags[tag] = {
                    type: valtype + (":" + subtype),
                    value: (function() {
                      var _l, _results1;
                      _results1 = [];
                      for (i = _l = 0; 0 <= arrayLen ? _l < arrayLen : _l > arrayLen; i = 0 <= arrayLen ? ++_l : --_l) {
                        _results1.push(buf.readInt8(cursor + i));
                      }
                      return _results1;
                    })()
                  };
                  cursor += arrayLen;
                  break;
                case "C":
                  tags[tag] = {
                    type: valtype + (":" + subtype),
                    value: (function() {
                      var _l, _results1;
                      _results1 = [];
                      for (i = _l = 0; 0 <= arrayLen ? _l < arrayLen : _l > arrayLen; i = 0 <= arrayLen ? ++_l : --_l) {
                        _results1.push(buf.readUInt8(cursor + i));
                      }
                      return _results1;
                    })()
                  };
                  cursor += arrayLen;
                  break;
                case "s":
                  tags[tag] = {
                    type: valtype + (":" + subtype),
                    value: (function() {
                      var _l, _results1;
                      _results1 = [];
                      for (i = _l = 0; 0 <= arrayLen ? _l < arrayLen : _l > arrayLen; i = 0 <= arrayLen ? ++_l : --_l) {
                        _results1.push(buf.readInt16LE(cursor + i * 2));
                      }
                      return _results1;
                    })()
                  };
                  cursor += arrayLen * 2;
                  break;
                case "S":
                  tags[tag] = {
                    type: valtype + (":" + subtype),
                    value: (function() {
                      var _l, _results1;
                      _results1 = [];
                      for (i = _l = 0; 0 <= arrayLen ? _l < arrayLen : _l > arrayLen; i = 0 <= arrayLen ? ++_l : --_l) {
                        _results1.push(buf.readUInt16LE(cursor + i * 2));
                      }
                      return _results1;
                    })()
                  };
                  cursor += arrayLen * 2;
                  break;
                case "i":
                  tags[tag] = {
                    type: valtype + (":" + subtype),
                    value: (function() {
                      var _l, _results1;
                      _results1 = [];
                      for (i = _l = 0; 0 <= arrayLen ? _l < arrayLen : _l > arrayLen; i = 0 <= arrayLen ? ++_l : --_l) {
                        _results1.push(buf.readInt32LE(cursor + i * 4));
                      }
                      return _results1;
                    })()
                  };
                  cursor += arrayLen * 4;
                  break;
                case "I":
                  tags[tag] = {
                    type: valtype + (":" + subtype),
                    value: (function() {
                      var _l, _results1;
                      _results1 = [];
                      for (i = _l = 0; 0 <= arrayLen ? _l < arrayLen : _l > arrayLen; i = 0 <= arrayLen ? ++_l : --_l) {
                        _results1.push(buf.readUInt32LE(cursor + i * 4));
                      }
                      return _results1;
                    })()
                  };
                  cursor += arrayLen * 4;
                  break;
                case "f":
                  tags[tag] = {
                    type: valtype + (":" + subtype),
                    value: (function() {
                      var _l, _results1;
                      _results1 = [];
                      for (i = _l = 0; 0 <= arrayLen ? _l < arrayLen : _l > arrayLen; i = 0 <= arrayLen ? ++_l : --_l) {
                        _results1.push(buf.readFloatLE(cursor + i * 4));
                      }
                      return _results1;
                    })()
                  };
                  cursor += arrayLen * 4;
              }
              break;
            case "Z":
              zLen = 0;
              while (buf[cursor + zLen] !== 0x00) {
                zLen++;
              }
              tags[tag] = {
                type: valtype,
                value: buf.slice(cursor, cursor + zLen).toString("ascii")
              };
              cursor += zLen + 1;
              break;
            case "H":
              hLen = 0;
              while (buf[cursor + hLen] !== 0x00) {
                hLen++;
              }
              tags[tag] = {
                type: valtype,
                value: buf.slice(cursor, cursor + hLen).toString("hex")
              };
              cursor += hLen + 1;
          }
        }
        buf = buf.slice(cursor);
        bamline = {
          qname: readName,
          flag: flag,
          rname: rname,
          pos: pos + 1,
          mapq: mapq,
          cigar: cigar,
          rnext: rnext,
          pnext: nextPos + 1,
          tlen: tLen,
          seq: seq,
          qual: qual,
          refid: refId,
          nrefid: nextRefId,
          tags: tags,
          start: pos,
          flags: flags,
          tagstr: ((function() {
            var _results1;
            _results1 = [];
            for (name in tags) {
              tag = tags[name];
              _results1.push([name, tag.type, tag.value].join(":"));
            }
            return _results1;
          })()).join("\t")
        };
        if (onBam) {
          onBam(bamline);
        }
        if (onSam) {
          samline = [bamline.qname, bamline.flag, bamline.rname, bamline.pos, bamline.mapq, bamline.cigar || "*", bamline.rnext === bamline.rname && bamline.rname !== "*" ? "=" : bamline.rnext, bamline.pnext, bamline.tlen, bamline.seq, bamline.qual, bamline.tagstr].join("\t");
          _results.push(onSam(samline));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
  };

  return BAMReader;

})();

module.exports = BAMReader;
